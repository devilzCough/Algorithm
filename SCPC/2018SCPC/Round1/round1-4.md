## Round 1 - 4 선형배치

NN개의 정점으로 구성된 그래프 G=(V,E)G=(V,E)가 있다. 각 정점은 0과 N−1N−1 사이의 번호로 구분된다.  모든 정점을 xx축 상에 선형적으로 배치하는 문제, 즉 x(0≤x≤N−1)x(0≤x≤N−1)의 각 위치에 정점을 하나씩 배치하는 문제를 고려하자. 선형 배치된 그래프의 정점 vv의 위치를 PvPv로 나타내면 두 정점 uu와 vv를 잇는 간선의 거리는 |Pu−Pv||Pu−Pv|가 된다.  그래프 G=(V,E)G=(V,E)가 주어질 때, EE에 속한 모든 간선의 길이 합이 가능한 최소가 되도록 정점을 선형 배치하는 프로그램을 작성하고자 한다.  예를 들어, <그림 1>에서 보인 것과 같은 그래프를 <그림 2>에서 보인 것처럼 배치하면 간선의 길이 합이 16이 되고, <그림 3>에서 보인 것처럼 배치하면 간선의 길이 합은 14가 된다.   ![img](https://cdn.codeground.org/resources/94facac0ce/AWQnG9QXAK9vpRkY.png)  ![img](https://cdn.codeground.org/resources/94facac0ce/AWQnG-bXALJvpRkY.png)   

- 제한시간: 전체 테스트 케이스는 30개 이하이며, 전체 수행 시간은 4초 이내. (Java 8초 이내) 



#### input

입력 파일에는 여러 테스트 케이스가 포함될 수 있다. 파일의 첫째 줄에 테스트 케이스의 개수를 나타내는 자연수 TT가 주어지고, 이후 차례로  TT개의 테스트 케이스가 주어진다. (1≤T≤30)(1≤T≤30)  각 테스트 케이스의 첫 줄에는 두 개의 정수N(5≤N≤100)N(5≤N≤100)과 M(4≤M≤1,000)M(4≤M≤1,000)이 순서대로 주어지며 각각은 입력 그래프의 정점의 개수와 간선의 개수를 의미한다.  다음 이어지는 MM개의 줄 각각에는 두 개의 정수 u,v(0≤u,v≤N−1)u,v(0≤u,v≤N−1) 가 주어지는데, 각 간선의 양 끝에 있는 정점의 번호를 나타낸다. 입력으로 주어지는 그래프는 다음과 같은 규칙으로 생성된다.  

① NN개의 정점을 무작위 순서로 일렬로 나열한 후, 인접한 정점사이엔 간선을 추가한다.

② 거리차이가 k(2≤k)k(2≤k)인 두 정점사이엔 0.8k0.8k의 확률로 간선이 추가된다.    

- 점수 : 최대 10회 제출하여 취득한 각각의 점수 중에서 최대 점수 (만점 200 점)     주어지는 테스트 케이스 데이터들의 그룹은 아래와 같다. 
  - 그룹 1 (40 점) : 이 그룹의 테스트 케이스에서는 N<9이다. 
  - 그룹 2 (160 점) : 이 그룹의 테스트 케이스에서는 별도의 제한이 없다.  
- 참고 : 이 문제는 기본적으로 최적의 해를 찾기 보다 상대적으로 좋은 결과를 찾는 문제이다. 단, 그룹 1의 경우 NN이 작기 때문에 최적의 해를 구할 수 있고, 따라서 그룹 1의 모든 테스트 케이스에 대해 최적해를 구해야 그룹 1에 할당된 부분점수를 받을 수 있다.  그룹 2의 테스트케이스에 대해선, 출제진이 가지고 있는 결과값 RR보다 동등하거나 좋은 결과를 생성하면 해당그룹에 할당된 만점을 받고, 그렇지 않으면 RR보다 나빠진 정도에 반비례하여 부분점수를 받을 것이다. 구체적으로, 여러분이 구한 결과를 LL, 각 테스트케이스에 할당된 만점을 PP라 두자. 만약, L≤RL≤R이면 PP 점을 받고, 그렇지 않으면 P(1−(L−R)2R)P(1−(L−R)2R)점을 받을 것이다. 만약 P(1−(L−R)2R)P(1−(L−R)2R)이 음수이면 0점으로 처리된다. 각 테스트 케이스에 대해 구한 점수의 합이 그룹 2에 대한 점수가 된다.



#### output

각 테스트 케이스의 답을 순서대로 표준출력으로 출력하여야 하며, 각 테스트 케이스마다 첫 줄에는 “Case #C”를 출력하여야 한다. 이때 C는 테스트 케이스의 번호이다. 그 다음 줄에 모든 간선의 길이 합을 출력하시오. 그 다음 줄엔 각 x(0≤x≤N−1)x(0≤x≤N−1) 좌표에 배치된 정점의 번호를 차례대로 출력하시오.